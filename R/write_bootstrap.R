## TODO: context_bootstrap is referenced with a hardcoded name in a
## few places and should not be.
##
## TODO: bootstrap will not install fresh context if it's found in
## surprising places; look *only* in lib.
setup_bootstrap <- function(root) {
  path <- path_version(root)
  written <- read_version(root)
  installed <- packageVersion("context")
  if (is.na(installed) || written < installed) {
    write_bootstrap(root)
    write_runner(root)
    build_local_drat(setup_bootstrap_self_sources(), path_drat(root))
    invisible(TRUE)
  } else if (written > installed) {
    ## This might get relaxed.
    stop("context version conflict; local is outdated")
  } else {
    invisible(FALSE)
  }
}

setup_bootstrap_self_sources <- function() {
  ## Add ourself.  Soon, this will be
  ##   dide-tools/context@ + paste0("v", packageVersion("context"))
  ## which will make things a bit more stable.
  ##
  ## storr will go on CRAN and then this simplifies.
  context <- Sys.getenv("CONTEXT_SOURCE_PATH")

  repos <- local <- NULL
  if (context == "") {
    repos <- "drat://richfitz"
  } else {
    local <- c(local, context)
  }

  package_sources(repos=repos, local=local)
}

read_version <- function(root) {
  filename <- path_version(root)
  if (file.exists(filename)) {
    package_version(readLines(filename))
  } else {
    package_version("0.0")
  }
}

## This attempts to write out enough of the package to bootstrap the
## package into working.  It uses the actual package functions rather
## than anything else so that's nice.
##
## One issue is that libcurl is going to be required to satisfy the
## curl dependency.  That's not very pleasant to deal with.  In the
## docker case we could attempt to fix that with an
##   apt-get update && apt-get -y libcurl4-openssl-dev
## but that seems to be asking a little too much.
##
##   platform <- function() {
##     name <- tolower(Sys.info()[["sysname"]])
##     if (name == "linux") {
##       tmp <- strsplit(readLines("/proc/self/cgroup") ":", fixed=TRUE)
##       if (any(grepl("docker", vapply(tmp, "[[", character(1), 3L)))) {
##         name <- "docker"
##       }
##     }
##     name
##   }
##
## But for now, I'll just require it.
##
## It would probably be better to stick the files into a drat and
## install off that; that removes any separate package installation
## (github urls etc).  and we could actually install it into a
## separate local library.  Only downside is that during development
## it's then difficult to get the most recent version.
write_bootstrap <- function(root) {
  bootstrap <- function(root) {
    options(context.log=TRUE)
    context_log("bootstrap", normalizePath(root))
    lib <- use_local_library(path_library(root))
    if ("context" %in% .packages(TRUE, lib)) {
      v_installed <- packageVersion("context", lib)
      v_needed <- read_version(root)
      if (v_installed >= v_needed) {
        context_log("ok", "")
        if (!isTRUE(v_installed >= v_needed)) {
          context_log("warn", "platform specific weirdness?")
        }
        return()
      } else {
        context_log("upgrade",
                    sprintf("context: %s -> %s", v_installed, v_needed))
      }
    } else {
      context_log("install", "context")
    }
    path_local_drat <- path_drat(root)
    ## NOTE: This line is needed to get context installed.  When
    ## context is on CRAN it could possibly be omitted.
    context_local <- length(dir(file.path(path_local_drat, "src/contrib"),
                                "^context_.*\\.tar\\.gz")) > 0L
    package_sources <- list(cran="http://cran.rstudio.com")
    if (context_local) {
      package_sources$local_drat <- path_local_drat
    } else {
      package_sources$repos <- "https://richfitz.github.io/drat/"
    }

    install_packages("context", lib=lib, sources=package_sources,
                     error=TRUE, move_in_place=TRUE)
    context_log("done", "")
  }
  main <- function() {
    ## The first clause here is used in the case where this file is
    ## source()'d in.
    if (exists("CONTEXT_ROOT")) {
      root <- get("CONTEXT_ROOT")
    } else {
      args <- commandArgs(TRUE)
      if (length(args) != 1L) {
        stop("Usage: context_bootstrap <root>")
      }
      root <- args[[1]]
    }
    bootstrap(root)
  }

  env <- environment(write_bootstrap)
  funs_context <- vcapply(find_funcs(bootstrap, env),
                          fun_to_str, env, USE.NAMES=FALSE)
  funs_bootstrap <- vcapply(c("bootstrap", "main"),
                            fun_to_str, environment(), USE.NAMES=FALSE)
  code <- c("#!/usr/bin/env Rscript",
            "# autogenerated by context; do not edit",
            "local({",
            "par <- new.env(parent=emptyenv())",
            funs_context,
            funs_bootstrap,
            "main()",
            "})")

  dir.create(root, FALSE, TRUE)
  writeLines(as.character(packageVersion(.packageName)), path_version(root))

  write_script(code, path_bin(root, "context_bootstrap"))
}

write_runner <- function(path) {
  env <- environment(install_context)
  funs <- vcapply(c("main_parse_args", find_funcs(main_parse_args, env)),
                  fun_to_str, env, USE.NAMES=FALSE)

  ## This code is a bit horiffic because we need to get everything in
  ## place so that context will be found.  That requires getting just
  ## enough so that use_local_library is found, and parsing the
  ## arguments to get the correct version.  This makes a much less
  ## robust runner than usual.  So at the same time we'll arrange to
  ## read the bootstrap script, too!
  code <- c("#!/usr/bin/env Rscript",
            "# autogenerated by context; do not edit",
            "library(methods)",
            'message("args:")',
            'message(paste(commandArgs(), collapse=", "))',
            "local({",
            funs,
            "args <- main_parse_args(commandArgs(TRUE))",
            "CONTEXT_ROOT <- args$root",
            'source(file.path(CONTEXT_ROOT, "bin", "context_bootstrap"), TRUE)',
            "})",
            "context:::main()")

  write_script(code, path_bin(path, "context_runner"))
}
